**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 â€“ Requirements-Based Test Generation**

| Group 9:         |     |
| --------------   | --- |
| Chloe Villaranda |     |
| Maheen Raza      |     |
| Mehrnaz Zafari   |     |
| Maham Jamal      |     |

# 1 Introduction

For the second assignment - Introduction to Unit Testing - in SENG 438, we looked at different ways to develop unit tests for two different classes: org.jfree.data.DataUtilities and org.jfree.data.Range. Different methods that were introduced in lectures were exercised, such as boundary value testing and creating equivalent classes. In comparsion to our last assignment, we were a lot more familar with unit testing than the testing strategies used in assignment 1. Unit testing is a lot more straight-forward and thorough, as we test specific functionalities, inputs and expected outputs.

# 2 Detailed description of unit test strategy

For org.jfree.data.DataUtilities:
In order to test the 5 different methods in the DataUtilities, I approached this testing scenario by creating test cases that might be most commonly used through the perspective of a user using the class.
For calculateColumnTotal:
Looking at the API specifications for this class, this method returns the sum of the values in one column of the supplied data table. With invalid input, a total of zero will be returned. In order to create test cases, I first did more obvious scenarios, like calculating the column total for positive, negative and mixed values for just two columns. I then tried calculating the column total for more than 2 columns. I then created test cases when the function returns an empty table, null data, or invalid data such as NaN values. The test cases created to use null and invalid data was to test if the expected exception that is specified in documentation is thrown or not.

For calculateRowTotal:
Similar to calculateColumnTotal, this method returns the sum of the values in one row of the supplied data table. With invalid input, a total of zero will be returned. To create test cases for this method, I repeated the same steps I followed when creating tests for calculateColumnTotal. I first did more obvious scenarios, like calculating the row total for positive, negative and mixed values for just two rows. I then tried calculating the row total for more than 2 rows. I then created test cases when the function returns an empty table, null data, or invalid data such as NaN values. The test cases created to use null and invalid data was to test if the expected exception that is specified in documentation is thrown or not.

For createNumberArray:
After browsing the API specifications for createNumberArray, this method is a bit different from the previous two arrays. This function is used to constructs an array of Number objects from an array of double primitives. Similar to the two methods above, I first created more obvious tests, by testing to see if the method worked when you created a number array with positive, negative, mixed or an empty values of doubles. Of course, in order to see if the InvalidParameterException is thrown or not, I created two test cases, one wear the arguments are null and another, where the arguments are NaN values.

For createNumberArray2D:
Similar to createNumberArray, I followed the same steps to create test cases, but this time for two-dimensional data. I created tests, again, to check if a 2D number array can be created by using positive, negative, mixed and empty array of data. I then checked to see if the InvalidParameterException gets thrown or not when you pass in a null table, or one with NaN values.

For getCumulativePercentages: 
Of course, I followed similar steps to the methods above to create test cases for getCumulativePercentages. I passed in a culmination of mixed, positive and and negative values to test how the method calculates the overall percentages, as well as testing what would happen if you were to pass empty data into KeyedValues. I also tested exception handling, passing in invalid data such as null or a NaN value to see if the appropriate exception was thrown or not.

# 3 Test cases developed

// write down the name of the test methods and classes. Organize the based on
the source code method // they test. identify which tests cover which partitions
you have explained in the test strategy section //above

For DataUtilitiesTest:

For method calculateColumnTotal:

Test case #1: calculateColumnTotalForTwoValidValues()
Test case #2: calculateColumnTotalForMoreThanTwoValidValues()
Test case #3: calculateColumnTotalForPositiveValuesOnly()
Test case #4: calculateColumnTotalForNegativeValuesOnly()
Test case #5: calculateColumnTotalWithPositiveAndNegativeValues()
Test case #6: calculateColumnTotalForSumOfZero()
Test case #7: calculateColumnTotalForEmptyDataTable()

For the cases above, these tests focused on the possible different data types that are valid, that can be passed in by users. With these data types, the given method should be able to calculate the column total efficiently, as described by the API specifications.

Test case #8: calculateColumnTotalWithNullData()
Test case #9: calculateColumnTotalWithInvalidData()

For the 2 cases above, these test cases specifically tested exception handling, and when it should occur. According to the API specifications, an InvalidParameterException must be thrown when any invalid data is passed in, and within the test cases, I pass in both null data, as well as invalid values such as NaN.

For method calculateRowTotal:

Test case #1: calculateRowTotalForTwoValidValues()
Test case #2: calculateRowTotalForMoreThanTwoValidValues()
Test case #3: calculateRowTotalWithForTwoPositiveValues()
Test case #4: calculateRowTotalWithForTwoNegativeValues()
Test case #5: calculateRowTotalWithANegativeAndPositiveValue()
Test case #6: calculateRowTotalForSumOfZero()
Test case #7: calculateRowTotalForEmptyDataTable()

Similar to above, test cases 1-7 focus on different types of data being stored in a Values2D object, like testing two rows vs three rows, having positive, negative or mixed values, and even if its empty.

Test case #8: calculateRowTotalWithNullData()
Test case #9: calculateRowTotalWithInvalidData()

Test cases 8 and 9 focus on testing exception handling when null or invalid data is stored in a Values2D object.

# 4 How the team work/effort was divided and managed
As there was a total of 20 test case designs, we evenly divided those designs by 4 and each member did 5 each. We paired up in groups of two to create the actual test cases and peer-reviewed the test cases each pair created with the other pair. Communication was also kept constant between all members of the team. 

# 5 Difficulties encountered, challenges overcome, and lessons learned
As creating test cases using the Eclipse IDE was the first time for all of the members of our team, we found difficulty in figuring out how things work. In our classes, we normally just make sure a certain aspect of a function is working and we neglect to test every single scenerio. What we learned through this lab is that we should take a methodical approach when it comes to testing the limitations of a certain function as it is the most effective in finding outputs that are expected/unexpected. 

# 6 Comments/feedback on the lab itself
3/4 of our members found problems when it came to the installation of the Eclipse IDE and adding external libraries. The tutorial images did not exactly match what we had on our screens. We managed through it and also realized that JUnit cases can be created on other tests. Would have been a plus to have tutorials on other IDEs though. 
