**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group 9:         |     |
| --------------   | --- |
| Chloe Villaranda |     |
| Maheen Raza      |     |
| Mehrnaz Zafari   |     |
| Maham Jamal      |     |

# 1 Introduction

For the second assignment - Introduction to Unit Testing - in SENG 438, we looked at different ways to develop unit tests for two different classes: org.jfree.data.DataUtilities and org.jfree.data.Range. Different methods that were introduced in lectures were exercised, such as boundary value testing and creating equivalent classes. In comparsion to our last assignment, we were a lot more familar with unit testing than the testing strategies used in assignment 1. Unit testing is a lot more straight-forward and thorough, as we test specific functionalities, inputs and expected outputs.

# 2 Detailed description of unit test strategy

For org.jfree.data.DataUtilities:
In order to test the 5 different methods in the DataUtilities, I approached this testing scenario by creating test cases that might be most commonly used through the perspective of a user using the class.
For calculateColumnTotal:
Looking at the API specifications for this class, this method returns the sum of the values in one column of the supplied data table. With invalid input, a total of zero will be returned. In order to create test cases, I first did more obvious scenarios, like calculating the column total for positive, negative and mixed values for just two columns. I then tried calculating the column total for more than 2 columns. I then created test cases when the function returns an empty table, null data, or invalid data such as NaN values. The test cases created to use null and invalid data was to test if the expected exception that is specified in documentation is thrown or not.

For calculateRowTotal:
Similar to calculateColumnTotal, this method returns the sum of the values in one row of the supplied data table. With invalid input, a total of zero will be returned. To create test cases for this method, I repeated the same steps I followed when creating tests for calculateColumnTotal. I first did more obvious scenarios, like calculating the row total for positive, negative and mixed values for just two rows. I then tried calculating the row total for more than 2 rows. I then created test cases when the function returns an empty table, null data, or invalid data such as NaN values. The test cases created to use null and invalid data was to test if the expected exception that is specified in documentation is thrown or not.

For createNumberArray:
After browsing the API specifications for createNumberArray, this method is a bit different from the previous two arrays. This function is used to constructs an array of Number objects from an array of double primitives. Similar to the two methods above, I first created more obvious tests, by testing to see if the method worked when you created a number array with positive, negative, mixed or an empty values of doubles. Of course, in order to see if the InvalidParameterException is thrown or not, I created two test cases, one wear the arguments are null and another, where the arguments are NaN values.

For createNumberArray2D:
Similar to createNumberArray, I followed the same steps to create test cases, but this time for two-dimensional data. I created tests, again, to check if a 2D number array can be created by using positive, negative, mixed and empty array of data. I then checked to see if the InvalidParameterException gets thrown or not when you pass in a null table, or one with NaN values.

For getCumulativePercentages: 
Of course, I followed similar steps to the methods above to create test cases for getCumulativePercentages. I passed in a culmination of mixed, positive and and negative values to test how the method calculates the overall percentages, as well as testing what would happen if you were to pass empty data into KeyedValues. I also tested exception handling, passing in invalid data such as null or a NaN value to see if the appropriate exception was thrown or not.

# 3 Test cases developed

// write down the name of the test methods and classes. Organize the based on
the source code method // they test. identify which tests cover which partitions
you have explained in the test strategy section //above

For For org.jfree.data.DataUtilities:


# 4 How the team work/effort was divided and managed

Text…

# 5 Difficulties encountered, challenges overcome, and lessons learned

Text…

# 6 Comments/feedback on the lab itself

Text…
